// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package acoremodrandomsuffix

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// IWSCTAxe is a ItemWeaponSubClass of type Axe.
	IWSCTAxe ItemWeaponSubClass = iota
	// IWSCTAxe2 is a ItemWeaponSubClass of type Axe2.
	IWSCTAxe2
	// IWSCTBow is a ItemWeaponSubClass of type Bow.
	IWSCTBow
	// IWSCTGun is a ItemWeaponSubClass of type Gun.
	IWSCTGun
	// IWSCTMace is a ItemWeaponSubClass of type Mace.
	IWSCTMace
	// IWSCTMace2 is a ItemWeaponSubClass of type Mace2.
	IWSCTMace2
	// IWSCTPolearm is a ItemWeaponSubClass of type Polearm.
	IWSCTPolearm
	// IWSCTSword is a ItemWeaponSubClass of type Sword.
	IWSCTSword
	// IWSCTSword2 is a ItemWeaponSubClass of type Sword2.
	IWSCTSword2
	// IWSCTObsolete is a ItemWeaponSubClass of type Obsolete.
	IWSCTObsolete
	// IWSCTStaff is a ItemWeaponSubClass of type Staff.
	IWSCTStaff
	// IWSCTExotic is a ItemWeaponSubClass of type Exotic.
	IWSCTExotic
	// IWSCTExotic2 is a ItemWeaponSubClass of type Exotic2.
	IWSCTExotic2
	// IWSCTFist is a ItemWeaponSubClass of type Fist.
	IWSCTFist
	// IWSCTMisc is a ItemWeaponSubClass of type Misc.
	IWSCTMisc
	// IWSCTDagger is a ItemWeaponSubClass of type Dagger.
	IWSCTDagger
	// IWSCTThrown is a ItemWeaponSubClass of type Thrown.
	IWSCTThrown
	// IWSCTSpear is a ItemWeaponSubClass of type Spear.
	IWSCTSpear
	// IWSCTCrossbow is a ItemWeaponSubClass of type Crossbow.
	IWSCTCrossbow
	// IWSCTWand is a ItemWeaponSubClass of type Wand.
	IWSCTWand
	// IWSCTFishingPole is a ItemWeaponSubClass of type FishingPole.
	IWSCTFishingPole
)

var ErrInvalidItemWeaponSubClass = fmt.Errorf("not a valid ItemWeaponSubClass, try [%s]", strings.Join(_ItemWeaponSubClassNames, ", "))

const _ItemWeaponSubClassName = "AxeAxe2BowGunMaceMace2PolearmSwordSword2ObsoleteStaffExoticExotic2FistMiscDaggerThrownSpearCrossbowWandFishingPole"

var _ItemWeaponSubClassNames = []string{
	_ItemWeaponSubClassName[0:3],
	_ItemWeaponSubClassName[3:7],
	_ItemWeaponSubClassName[7:10],
	_ItemWeaponSubClassName[10:13],
	_ItemWeaponSubClassName[13:17],
	_ItemWeaponSubClassName[17:22],
	_ItemWeaponSubClassName[22:29],
	_ItemWeaponSubClassName[29:34],
	_ItemWeaponSubClassName[34:40],
	_ItemWeaponSubClassName[40:48],
	_ItemWeaponSubClassName[48:53],
	_ItemWeaponSubClassName[53:59],
	_ItemWeaponSubClassName[59:66],
	_ItemWeaponSubClassName[66:70],
	_ItemWeaponSubClassName[70:74],
	_ItemWeaponSubClassName[74:80],
	_ItemWeaponSubClassName[80:86],
	_ItemWeaponSubClassName[86:91],
	_ItemWeaponSubClassName[91:99],
	_ItemWeaponSubClassName[99:103],
	_ItemWeaponSubClassName[103:114],
}

// ItemWeaponSubClassNames returns a list of possible string values of ItemWeaponSubClass.
func ItemWeaponSubClassNames() []string {
	tmp := make([]string, len(_ItemWeaponSubClassNames))
	copy(tmp, _ItemWeaponSubClassNames)
	return tmp
}

var _ItemWeaponSubClassMap = map[ItemWeaponSubClass]string{
	IWSCTAxe:         _ItemWeaponSubClassName[0:3],
	IWSCTAxe2:        _ItemWeaponSubClassName[3:7],
	IWSCTBow:         _ItemWeaponSubClassName[7:10],
	IWSCTGun:         _ItemWeaponSubClassName[10:13],
	IWSCTMace:        _ItemWeaponSubClassName[13:17],
	IWSCTMace2:       _ItemWeaponSubClassName[17:22],
	IWSCTPolearm:     _ItemWeaponSubClassName[22:29],
	IWSCTSword:       _ItemWeaponSubClassName[29:34],
	IWSCTSword2:      _ItemWeaponSubClassName[34:40],
	IWSCTObsolete:    _ItemWeaponSubClassName[40:48],
	IWSCTStaff:       _ItemWeaponSubClassName[48:53],
	IWSCTExotic:      _ItemWeaponSubClassName[53:59],
	IWSCTExotic2:     _ItemWeaponSubClassName[59:66],
	IWSCTFist:        _ItemWeaponSubClassName[66:70],
	IWSCTMisc:        _ItemWeaponSubClassName[70:74],
	IWSCTDagger:      _ItemWeaponSubClassName[74:80],
	IWSCTThrown:      _ItemWeaponSubClassName[80:86],
	IWSCTSpear:       _ItemWeaponSubClassName[86:91],
	IWSCTCrossbow:    _ItemWeaponSubClassName[91:99],
	IWSCTWand:        _ItemWeaponSubClassName[99:103],
	IWSCTFishingPole: _ItemWeaponSubClassName[103:114],
}

// String implements the Stringer interface.
func (x ItemWeaponSubClass) String() string {
	if str, ok := _ItemWeaponSubClassMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ItemWeaponSubClass(%d)", x)
}

var _ItemWeaponSubClassValue = map[string]ItemWeaponSubClass{
	_ItemWeaponSubClassName[0:3]:     IWSCTAxe,
	_ItemWeaponSubClassName[3:7]:     IWSCTAxe2,
	_ItemWeaponSubClassName[7:10]:    IWSCTBow,
	_ItemWeaponSubClassName[10:13]:   IWSCTGun,
	_ItemWeaponSubClassName[13:17]:   IWSCTMace,
	_ItemWeaponSubClassName[17:22]:   IWSCTMace2,
	_ItemWeaponSubClassName[22:29]:   IWSCTPolearm,
	_ItemWeaponSubClassName[29:34]:   IWSCTSword,
	_ItemWeaponSubClassName[34:40]:   IWSCTSword2,
	_ItemWeaponSubClassName[40:48]:   IWSCTObsolete,
	_ItemWeaponSubClassName[48:53]:   IWSCTStaff,
	_ItemWeaponSubClassName[53:59]:   IWSCTExotic,
	_ItemWeaponSubClassName[59:66]:   IWSCTExotic2,
	_ItemWeaponSubClassName[66:70]:   IWSCTFist,
	_ItemWeaponSubClassName[70:74]:   IWSCTMisc,
	_ItemWeaponSubClassName[74:80]:   IWSCTDagger,
	_ItemWeaponSubClassName[80:86]:   IWSCTThrown,
	_ItemWeaponSubClassName[86:91]:   IWSCTSpear,
	_ItemWeaponSubClassName[91:99]:   IWSCTCrossbow,
	_ItemWeaponSubClassName[99:103]:  IWSCTWand,
	_ItemWeaponSubClassName[103:114]: IWSCTFishingPole,
}

// ParseItemWeaponSubClass attempts to convert a string to a ItemWeaponSubClass.
func ParseItemWeaponSubClass(name string) (ItemWeaponSubClass, error) {
	if x, ok := _ItemWeaponSubClassValue[name]; ok {
		return x, nil
	}
	return ItemWeaponSubClass(0), fmt.Errorf("%s is %w", name, ErrInvalidItemWeaponSubClass)
}

// MarshalText implements the text marshaller method.
func (x ItemWeaponSubClass) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ItemWeaponSubClass) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseItemWeaponSubClass(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errItemWeaponSubClassNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ItemWeaponSubClass) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ItemWeaponSubClass(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = ItemWeaponSubClass(v)
	case string:
		*x, err = ParseItemWeaponSubClass(v)
	case []byte:
		*x, err = ParseItemWeaponSubClass(string(v))
	case ItemWeaponSubClass:
		*x = v
	case int:
		*x = ItemWeaponSubClass(v)
	case *ItemWeaponSubClass:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = *v
	case uint:
		*x = ItemWeaponSubClass(v)
	case uint64:
		*x = ItemWeaponSubClass(v)
	case *int:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = ItemWeaponSubClass(*v)
	case *int64:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = ItemWeaponSubClass(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = ItemWeaponSubClass(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = ItemWeaponSubClass(*v)
	case *uint:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = ItemWeaponSubClass(*v)
	case *uint64:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x = ItemWeaponSubClass(*v)
	case *string:
		if v == nil {
			return errItemWeaponSubClassNilPtr
		}
		*x, err = ParseItemWeaponSubClass(*v)
	}

	return
}

// Value implements the driver Valuer interface.
func (x ItemWeaponSubClass) Value() (driver.Value, error) {
	return x.String(), nil
}
